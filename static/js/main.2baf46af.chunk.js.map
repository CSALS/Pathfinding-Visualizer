{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingAlgorithms/dijkstra.js","PathfindingAlgorithms/dfs.js","PathfindingAlgorithms/astar.js","MazeAlgorithms/dfsMaze.js","MazeAlgorithms/recursiveDivision.js","PathfindingVisualizer/PathfindingVisualizer.jsx","PathfindingAlgorithms/bfs.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","row","col","isEnd","isStart","isWall","isWeight","onMouseClick","onMouseEnter","extraClassName","id","className","onClick","Component","dijkstra","grid","startNode","finishNode","diagonal","visitedNodesInOrder","distance","allNodes","nodes","node","push","getAllNodes","iterations","length","closestNode","getClosestUnvisitedNode","Infinity","isVisited","side_nodes_x","side_nodes_y","i","new_x","new_y","neighbor","edge_wt","previousNode","diagonal_nodes_x","diagonal_nodes_y","minDistance","console","log","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","dfs","endNode","dfsRecursive","astar","f","g","h","heuristic","side_neighbor","diagonal_neighbor","getSideNeighbors","getDiagonalNeighbors","open_list","current","nodeWithLeast_f","index","indexOf","splice","g_temp","isNeighborInOpenSet","eachNode","type","Math","abs","dfsMaze","start_x","start_y","start_node","dfsMazeUtil","x","y","array","j","floor","random","side_nodes_x1","side_nodes_y1","side_nodes_x2","side_nodes_y2","stack_child","k","new_x2","new_y2","new_x1","new_y1","childNode","pop","recursiveDivision","HEIGHT","WIDTH","node1","node2","recursiveDivisionUtil","startX","endX","startY","endY","orientation","getOrientation","wallX","getRandomInteger","skipY","wallY","skipX","min","max","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","stopAnimating","PathfindingVisualizer","state","isPlaceStart","isPlaceEnd","isPlaceWeight","isPlaceWall","startPresent","endPresent","isMousePressed","getInitialGrid","setState","document","getElementById","addEventListener","newGrid","getNewGridWithWallToggled","getNewGridWithWeightToggled","isSameNode","getNewGridWithStartToggled","getNewGridWithEndToggled","enableExceptClearboard","refreshBoardForPathfinding","flag","algorithmsContainer","getElementsByClassName","style","display","algo","noDiagonal","disabled","background","visualizeButtons","placeStartNode","placeEndNode","placeWallNode","title","placeWeightNode","handleAlgorithmsDropdown","handleEachAlgorithmDropdown","visualizeBFS","visualizeDFS","visualizeDijkstra","visualizeAStar","visualizeDFSMaze","visualizeRecursiveDivision","clearBoard","getPrevBoard","map","rowIdx","key","nodeIdx","handleMouseClick","handleMouseEnter","currGrid","slice","alert","innerHTML","disableExceptClearboard","animateVisitedNodes","queue","shift","bfs","animatingShortestPath","animateShortestPath","animate","requestAnimationFrame","firstNodeInShortestPath","refreshBoardForMaze","animateMaze","currentRow","createNode","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.2baf46af.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row, col,\n      isEnd,\n      isStart,\n      isWall,\n      isWeight,\n      onMouseClick,\n      onMouseEnter,\n    } = this.props;\n\n    const extraClassName = isEnd ? 'node-finish' : isStart ? 'node-start' : isWall ? 'node-wall' : isWeight ? 'node-weight' : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onClick={() => onMouseClick(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n      >\n      </div>\n    );\n  }\n}\n","// visitedNodesInOrder = Stores the order in which nodes are visited\n\n\nexport function dijkstra(grid, startNode, finishNode, diagonal) {\n\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const allNodes = getAllNodes(grid);\n  let iterations = allNodes.length;\n  while (iterations--) {\n    // Get the node with minimum distance and not visited\n    const closestNode = getClosestUnvisitedNode(allNodes);\n\n    if (closestNode === null) return visitedNodesInOrder;\n\n    // If this closest node distance is Infinity then we are trapped\n    // so we stop and return the nodes visited till now\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    // Push this closestNode in the visited nodes array and make it visited as true\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n\n    // If the closestNode is the finishNode which is the target we are done\n    // so return the nodes visited\n    if (closestNode === finishNode) return visitedNodesInOrder;\n\n    // Update the distance of the neighbours of the closestNode\n    const side_nodes_x = [0, 0, 1, -1];\n    const side_nodes_y = [1, -1, 0, 0];\n\n    for (let i = 0; i < 4; ++i) {\n      const { col, row } = closestNode;\n      const new_x = row + side_nodes_x[i];\n      const new_y = col + side_nodes_y[i];\n      if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\n      const neighbor = grid[new_x][new_y];\n      if (neighbor.isVisited == true || neighbor.isWall == true) continue;\n      if (closestNode.distance + 1 < neighbor.distance) {\n        let edge_wt = 1;\n        if (neighbor.isWeight) edge_wt *= 10;\n        neighbor.distance = closestNode.distance + edge_wt;\n        neighbor.previousNode = closestNode;\n      }\n    }\n    if (diagonal === true) {\n      const diagonal_nodes_x = [1, 1, -1, -1];\n      const diagonal_nodes_y = [1, -1, 1, -1];\n\n      for (let i = 0; i < 4; ++i) {\n        const { col, row } = closestNode;\n        const new_x = row + diagonal_nodes_x[i];\n        const new_y = col + diagonal_nodes_y[i];\n        if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\n        const neighbor = grid[new_x][new_y];\n        if (neighbor.isVisited == true || neighbor.isWall == true) continue;\n        if (closestNode.distance + 1.2 < neighbor.distance) {\n          let edge_wt = 1.2;\n          if (neighbor.isWeight) edge_wt *= 10;\n          neighbor.distance = closestNode.distance + edge_wt;\n          neighbor.previousNode = closestNode;\n        }\n      }\n    }\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction getClosestUnvisitedNode(allNodes) {\n  let closestNode = null;\n  let minDistance = Infinity;\n  for (const node of allNodes) {\n    // console.log(node)\n    if (node.isVisited == true || node.isWall == true) continue;\n    if (node.distance < minDistance) {\n      closestNode = node;\n      minDistance = node.distance;\n    }\n  }\n  console.log(closestNode);\n  return closestNode;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the pathfinding algorithm is called above.\n// This method is same for any algorithm\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","export function dfs(grid, startNode, endNode, diagonal) {\r\n    const visitedNodesInOrder = [];\r\n    dfsRecursive(grid, startNode, endNode, visitedNodesInOrder, diagonal);\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction dfsRecursive(grid, node, endNode, visitedNodesInOrder, diagonal) {\r\n    node.isVisited = true;\r\n    visitedNodesInOrder.push(node);\r\n\r\n    if (node === endNode) return true;\r\n\r\n    const side_nodes_x = [0, 0, 1, -1];\r\n    const side_nodes_y = [1, -1, 0, 0];\r\n\r\n    for (let i = 0; i < 4; ++i) {\r\n        const { col, row } = node;\r\n        const new_x = row + side_nodes_x[i];\r\n        const new_y = col + side_nodes_y[i];\r\n        if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\r\n        const neighbor = grid[new_x][new_y];\r\n        if (neighbor.isVisited === true || neighbor.isWall === true) continue;\r\n        neighbor.previousNode = node;\r\n        if (dfsRecursive(grid, neighbor, endNode, visitedNodesInOrder, diagonal)) return true;\r\n    }\r\n    if (diagonal === true) {\r\n        const diagonal_nodes_x = [1, 1, -1, -1];\r\n        const diagonal_nodes_y = [1, -1, 1, -1];\r\n\r\n        for (let i = 0; i < 4; ++i) {\r\n            const { col, row } = node;\r\n            const new_x = row + diagonal_nodes_x[i];\r\n            const new_y = col + diagonal_nodes_y[i];\r\n            if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\r\n            const neighbor = grid[new_x][new_y];\r\n            if (neighbor.isVisited === true || neighbor.isWall === true) continue;\r\n            neighbor.previousNode = node;\r\n            if (dfsRecursive(grid, neighbor, endNode, visitedNodesInOrder, diagonal)) return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n\r\n}","// Pseudo Code - https://www.geeksforgeeks.org/a-search-algorithm/\r\n\r\nexport function astar(grid, startNode, finishNode, diagonal) {\r\n    const visitedNodesInOrder = [];\r\n\r\n    const allNodes = getAllNodes(grid);\r\n\r\n    for (const node of allNodes) {\r\n        node.f = Infinity;\r\n        node.g = Infinity;\r\n        node.h = heuristic(node, finishNode, \"manhattan\");\r\n        node.side_neighbor = [];\r\n        node.diagonal_neighbor = [];\r\n    }\r\n    getSideNeighbors(allNodes, grid);\r\n    if (diagonal === true) getDiagonalNeighbors(allNodes, grid);\r\n    const open_list = [startNode];\r\n    startNode.g = 0;\r\n    startNode.f = startNode.h;\r\n\r\n\r\n    while (open_list.length != 0) {\r\n        // Find the node with least 'f' on the open list\r\n        const current = nodeWithLeast_f(open_list);\r\n        if (current === null) {\r\n            console.log(\"Error: A* = Unable to retrieve node with least f value\")\r\n            return visitedNodesInOrder;\r\n        }\r\n        visitedNodesInOrder.push(current);\r\n        if (current.row === finishNode.row && current.col === finishNode.col) {\r\n            return visitedNodesInOrder;\r\n        }\r\n        // Remove that node from the open list\r\n        const index = open_list.indexOf(current);\r\n        if (index > -1) {\r\n            open_list.splice(index, 1);\r\n        }\r\n        // Generate successors of 'q' and set their parent to 'q'\r\n\r\n        // 1. Side Neighbors\r\n        for (const neighbor of current.side_neighbor) {\r\n            let edge_wt = 1;\r\n            if (neighbor.isWeight) edge_wt *= 10;\r\n            const g_temp = current.g + edge_wt;\r\n            if (g_temp < neighbor.g) {\r\n                neighbor.previousNode = current;\r\n                neighbor.g = g_temp;\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                if (!isNeighborInOpenSet(neighbor, open_list)) {\r\n                    open_list.push(neighbor);\r\n                }\r\n            }\r\n        }\r\n        // 2. Diagonal Neighbors\r\n        if (diagonal === true) {\r\n            for (const neighbor of current.diagonal_neighbor) {\r\n                let edge_wt = 1.2;\r\n                if (neighbor.isWeight) edge_wt *= 10;\r\n                const g_temp = current.g + edge_wt;\r\n                if (g_temp < neighbor.g) {\r\n                    neighbor.previousNode = current;\r\n                    neighbor.g = g_temp;\r\n                    neighbor.f = neighbor.g + neighbor.h;\r\n                    if (!isNeighborInOpenSet(neighbor, open_list)) {\r\n                        open_list.push(neighbor);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // No path\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction isNeighborInOpenSet(node, open_list) {\r\n    for (const eachNode of open_list) {\r\n        if (node.row === eachNode.row && node.col === eachNode.col) return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction nodeWithLeast_f(open_list) {\r\n    let closestNode = null;\r\n    let minDistance = Infinity;\r\n    for (const node of open_list) {\r\n        if (node.isWall == true) continue;\r\n        if (node.f < minDistance) {\r\n            closestNode = node;\r\n            minDistance = node.f;\r\n        }\r\n    }\r\n    return closestNode;\r\n}\r\n\r\nfunction heuristic(node, finishNode, type) {\r\n    if (type === \"manhattan\") {\r\n        return Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col);\r\n    }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction getSideNeighbors(allNodes, grid) {\r\n    for (const node of allNodes) {\r\n        const side_nodes_x = [0, 0, 1, -1];\r\n        const side_nodes_y = [1, -1, 0, 0];\r\n\r\n        for (let i = 0; i < 4; ++i) {\r\n            const { col, row } = node;\r\n            const new_x = row + side_nodes_x[i];\r\n            const new_y = col + side_nodes_y[i];\r\n            if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\r\n            const neighbor = grid[new_x][new_y];\r\n            if (neighbor.isWall == true) continue;\r\n            node.side_neighbor.push(neighbor);\r\n        }\r\n    }\r\n}\r\n\r\nfunction getDiagonalNeighbors(allNodes, grid) {\r\n    for (const node of allNodes) {\r\n        const diagonal_nodes_x = [1, 1, -1, -1];\r\n        const diagonal_nodes_y = [1, -1, 1, -1];\r\n\r\n        for (let i = 0; i < 4; ++i) {\r\n            const { col, row } = node;\r\n            const new_x = row + diagonal_nodes_x[i];\r\n            const new_y = col + diagonal_nodes_y[i];\r\n            if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\r\n            const neighbor = grid[new_x][new_y];\r\n            if (neighbor.isWall == true) continue;\r\n            node.diagonal_neighbor.push(neighbor);\r\n        }\r\n    }\r\n}\r\n","export function dfsMaze(grid, start_x, start_y) {\r\n    const start_node = grid[start_x][start_y];\r\n    start_node.isVisited = true;\r\n    start_node.isWall = true;\r\n    const visitedNodesInOrder = [start_node];\r\n    console.log(start_x, start_y);\r\n    dfsMazeUtil(grid, start_x, start_y, visitedNodesInOrder);\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n\r\nfunction dfsMazeUtil(grid, x, y, visitedNodesInOrder) {\r\n    const node = grid[x][y];\r\n    // Shuffling indexes\r\n    const array = [0, 1, 2, 3];\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    console.log(array);\r\n    const side_nodes_x1 = [0, 0, 1, -1];\r\n    const side_nodes_y1 = [1, -1, 0, 0];\r\n    const side_nodes_x2 = [0, 0, 2, -2];\r\n    const side_nodes_y2 = [2, -2, 0, 0];\r\n    const stack_child = [];\r\n    for (let k = 0; k <= 3; ++k) {\r\n        const i = array[k];\r\n        const { col, row } = node;\r\n        const new_x2 = row + side_nodes_x2[i];\r\n        const new_y2 = col + side_nodes_y2[i];\r\n        if (!(new_x2 >= 0 && new_y2 >= 0 && new_x2 < grid.length && new_y2 < grid[0].length)) continue;\r\n        const neighbor = grid[new_x2][new_y2];\r\n        if (neighbor.isVisited === true || neighbor.isWall === true) continue;\r\n        const new_x1 = row + side_nodes_x1[i];\r\n        const new_y1 = col + side_nodes_y1[i];\r\n        if ((new_x1 >= 0 && new_y1 >= 0 && new_x1 < grid.length && new_y1 < grid[0].length)) {\r\n            grid[new_x1][new_y1].isWall = true;\r\n            grid[new_x1][new_y1].isVisited = true;\r\n            visitedNodesInOrder.push(grid[new_x1][new_y1]);\r\n        }\r\n        stack_child.push({ 'x': new_x2, 'y': new_y2 });\r\n        const childNode = grid[new_x2][new_y2];\r\n        childNode.isVisited = true;\r\n        childNode.isWall = true;\r\n        visitedNodesInOrder.push(grid[new_x2][new_y2]);\r\n        // dfsMazeUtil(grid, new_x2, new_y2, visitedNodesInOrder);\r\n    }\r\n    // console.log(stack_child)\r\n    while (stack_child.length != 0) {\r\n        const node = stack_child.pop();\r\n        dfsMazeUtil(grid, node['x'], node['y'], visitedNodesInOrder);\r\n    }\r\n}","export function recursiveDivision(grid) {\r\n    const visitedNodesInOrder = [];\r\n    const HEIGHT = grid.length;\r\n    const WIDTH = grid[0].length;\r\n    for (let x = 0; x < HEIGHT; ++x) {\r\n        const node1 = grid[x][0], node2 = grid[x][WIDTH - 1];\r\n        node1.isWall = true;\r\n        node2.isWall = true;\r\n        visitedNodesInOrder.push(node1);\r\n        visitedNodesInOrder.push(node2);\r\n    }\r\n    for (let y = 0; y < WIDTH; ++y) {\r\n        const node1 = grid[0][y], node2 = grid[HEIGHT - 1][y];\r\n        node1.isWall = true;\r\n        node2.isWall = true;\r\n        visitedNodesInOrder.push(node1);\r\n        visitedNodesInOrder.push(node2);\r\n    }\r\n    recursiveDivisionUtil(grid, visitedNodesInOrder, 1, HEIGHT - 2, 1, WIDTH - 2);\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n/*\r\nparams = (x, y) are the top-left coordinates of the grid section.\r\n        (HEIGHT, WIDTH) are the size\r\n\r\nfunction = basically it chooses draws either horizontal or vertical wall line and skips one node to leave a passage\r\nand calls the function on both sides of section.\r\nif HEIGHT > WIDTH use horizontal\r\nelse if WIDTH > HEIGHT use vertical\r\nelse take random one\r\n*/\r\nfunction recursiveDivisionUtil(grid, visitedNodesInOrder, startX, endX, startY, endY) {\r\n    const HEIGHT = endX - startX + 1;\r\n    const WIDTH = endY - startY + 1;\r\n    // Base Case\r\n    if (HEIGHT <= 2 || WIDTH <= 2)\r\n        return;\r\n    // Corner Case\r\n    if (startX < 0 || startY < 0 || endX >= grid.length || endY >= grid[0].length || startX > endX || startY > endY)\r\n        return;\r\n    // Choose orientation\r\n    const orientation = getOrientation(HEIGHT, WIDTH);\r\n    // Generate the wall and divide the grid and call recursively\r\n    if (orientation === \"Horizontal\") {\r\n        // console.log(\"Horizontal \", startX, startY, endX, endY);\r\n        const wallX = getRandomInteger(startX + 1, endX - 1);\r\n        const skipY = getRandomInteger(startY, endY);\r\n        for (let wallY = startY; wallY <= endY; ++wallY) {\r\n            if (wallY === skipY) continue;\r\n            const node = grid[wallX][wallY];\r\n            node.isWall = true;\r\n            visitedNodesInOrder.push(node);\r\n        }\r\n        recursiveDivisionUtil(grid, visitedNodesInOrder, startX, wallX - 1, startY, endY); //Above\r\n        recursiveDivisionUtil(grid, visitedNodesInOrder, wallX + 1, endX, startY, endY); //Below\r\n    }\r\n    else if (orientation === \"Vertical\") {\r\n        // console.log(\"Vertical \", startX, startY, endX, endY);\r\n        const wallY = getRandomInteger(startY + 1, endY - 1);\r\n        const skipX = getRandomInteger(startX, endX);\r\n        for (let wallX = startX; wallX <= endX; ++wallX) {\r\n            if (wallX === skipX) continue;\r\n            const node = grid[wallX][wallY];\r\n            node.isWall = true;\r\n            visitedNodesInOrder.push(node);\r\n        }\r\n        recursiveDivisionUtil(grid, visitedNodesInOrder, startX, endX, startY, wallY - 1); //Left\r\n        recursiveDivisionUtil(grid, visitedNodesInOrder, startX, endX, wallY + 1, endY); //Right\r\n    }\r\n}\r\n\r\nconst getOrientation = (HEIGHT, WIDTH) => {\r\n    let orientation = null;\r\n    if (HEIGHT > WIDTH) {\r\n        orientation = \"Horizontal\";\r\n    }\r\n    else if (WIDTH > HEIGHT) {\r\n        orientation = \"Vertical\";\r\n    }\r\n    else {\r\n        const i = getRandomInteger(1, 2);\r\n        if (i === 1) orientation = \"Horizontal\";\r\n        else orientation = \"Vertical\";\r\n    }\r\n    return orientation;\r\n}\r\n\r\nconst getRandomInteger = (min, max) => {\r\n    max = max + 1;\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n}","import React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra, getNodesInShortestPathOrder } from '../PathfindingAlgorithms/dijkstra';\nimport { bfs } from '../PathfindingAlgorithms/bfs';\nimport { dfs } from '../PathfindingAlgorithms/dfs';\nimport { astar } from '../PathfindingAlgorithms/astar';\nimport { dfsMaze } from '../MazeAlgorithms/dfsMaze';\nimport { recursiveDivision } from '../MazeAlgorithms/recursiveDivision';\n\nimport './PathfindingVisualizer.css';\n\nconst getRandomInteger = (min, max) => {\n  max = max + 1;\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n// Parameters\nvar TIME_INTERVAL = 25;\nvar HEIGHT = 20;\nvar WIDTH = 50;\nvar START_NODE_ROW = -1;\nvar START_NODE_COL = -1;\nvar FINISH_NODE_ROW = -1;\nvar FINISH_NODE_COL = -1;\nvar stopAnimating = false;\nvar pause = false;\n\n// var START_NODE_ROW = getRandomInteger(0, HEIGHT);\n// var START_NODE_COL = getRandomInteger(0, WIDTH);\n// var FINISH_NODE_ROW = getRandomInteger(0, HEIGHT);\n// var FINISH_NODE_COL = getRandomInteger(0, WIDTH);\n// while (START_NODE_ROW == FINISH_NODE_ROW) {\n//   FINISH_NODE_ROW = getRandomInteger(0, HEIGHT);\n// }\n// while (START_NODE_COL == FINISH_NODE_COL) {\n//   FINISH_NODE_COL = getRandomInteger(0, WIDTH);\n// }\n\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      isPlaceStart: false,\n      isPlaceEnd: false,\n      isPlaceWeight: false,\n      isPlaceWall: false,\n      startPresent: false,\n      endPresent: false,\n      isMousePressed: false,\n    };\n  }\n  componentDidMount() {\n    stopAnimating = false;\n    pause = false;\n    const grid = getInitialGrid();\n    this.setState({ grid: grid });\n    document.getElementById('stopAnimating').addEventListener('click', function () {\n      stopAnimating = true;\n    });\n    document.getElementById('pauseAnimating').addEventListener('click', function () {\n      pause = true;\n    });\n    document.getElementById('playAnimating').addEventListener('click', function () {\n      pause = false;\n    });\n  }\n  placeStartNode() {\n    this.setState({ isPlaceStart: true });\n  }\n  placeEndNode() {\n    this.setState({ isPlaceEnd: true });\n  }\n  placeWallNode() {\n    this.setState({ isPlaceWall: true });\n  }\n  placeWeightNode() {\n    this.setState({ isPlaceWeight: true });\n  }\n\n  handleMouseClick(row, col) {\n    console.log(\"A cell is clicked\")\n    const { isPlaceStart, isPlaceEnd, endPresent, startPresent, isMousePressed, isPlaceWeight, isPlaceWall } = this.state;\n    let newGrid = null;\n    if (isMousePressed) {\n      console.log(\"Back to normal state\");\n      this.setState({ isMousePressed: false, isPlaceWall: false, isPlaceWeight: false });\n      return;\n    }\n    else if (isPlaceWall) {\n      console.log(\"Placing wall node\");\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ isMousePressed: true });\n    }\n    else if (isPlaceWeight) {\n      newGrid = getNewGridWithWeightToggled(this.state.grid, row, col);\n      this.setState({ isMousePressed: true });\n    }\n    else if (isPlaceStart) {\n      const isSameNode = (row == START_NODE_ROW && col == START_NODE_COL)\n      if (!isSameNode && startPresent) {\n        console.log(\"Start Node already present\");\n        return;\n      }\n\n      newGrid = getNewGridWithStartToggled(this.state.grid, row, col);\n      START_NODE_ROW = row;\n      START_NODE_COL = col;\n      if (isSameNode) {\n        this.setState({ startPresent: false });\n      }\n      else {\n        this.setState({ startPresent: true });\n      }\n    }\n    else if (isPlaceEnd) {\n      const isSameNode = (row == FINISH_NODE_ROW && col == FINISH_NODE_COL);\n      if (!isSameNode && endPresent) {\n        console.log(\"End Node already present\");\n        return;\n      }\n\n      newGrid = getNewGridWithEndToggled(this.state.grid, row, col);\n      FINISH_NODE_ROW = row;\n      FINISH_NODE_COL = col;\n      if (isSameNode) {\n        this.setState({ endPresent: false });\n      }\n      else {\n        this.setState({ endPresent: true });\n      }\n    }\n\n    if (newGrid === null) {\n      console.log(\"Error in handling mouse click\");\n      return;\n    }\n    this.setState({ grid: newGrid, isPlaceStart: false, isPlaceEnd: false });\n  }\n\n  handleMouseEnter(row, col) {\n    const { isPlaceStart, isPlaceEnd, isMousePressed, isPlaceWeight, isPlaceWall, startPresent, endPresent } = this.state;\n    if (isPlaceEnd || isPlaceStart) {\n      console.log(\"Placing start or end node.Cant drag\");\n      return;\n    }\n    if (!isMousePressed) {\n      console.log(\"Mouse is not being dragged\");\n      return;\n    }\n    if (startPresent && row == START_NODE_ROW && col == START_NODE_COL) {\n      console.log(\"start present on that cell.cant place wall\")\n      return;\n    }\n    if (endPresent && row == FINISH_NODE_ROW && col == FINISH_NODE_COL) {\n      console.log(\"end present on that cell.cant place wall\")\n      return;\n    }\n    let newGrid = null;\n    if (isPlaceWall) {\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid });\n    }\n    else if (isPlaceWeight) {\n      newGrid = getNewGridWithWeightToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid });\n    }\n  }\n\n  clearBoard() {\n    const grid = getInitialGrid();\n    for (let row = 0; row < grid.length; ++row) {\n      for (let col = 0; col < grid[0].length; ++col) {\n        document.getElementById(`node-${row}-${col}`).className = 'node';\n      }\n    }\n    this.setState({\n      grid: grid, isPlaceStart: false,\n      isPlaceEnd: false,\n      isPlaceWeight: false,\n      isPlaceWall: false,\n      startPresent: false,\n      endPresent: false,\n      isMousePressed: false,\n    });\n    this.enableExceptClearboard();\n    START_NODE_ROW = -1;\n    START_NODE_COL = -1;\n    FINISH_NODE_ROW = -1;\n    FINISH_NODE_COL = -1;\n    stopAnimating = false;\n    pause = false;\n  }\n\n  getPrevBoard() {\n    const grid = this.refreshBoardForPathfinding(this.state.grid);\n    for (const row of grid) {\n      for (const node of row) {\n        let flag = false\n        if (node.isStart === true) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-start';\n          flag = true\n        }\n        if (node.isEnd === true) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-finish';\n          flag = true\n        }\n        if (node.isWall === true) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-wall';\n          flag = true\n        }\n        if (node.isWeight == true) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-weight';\n          flag = true\n        }\n        // Rest other nodes which were visualized as visited & shortest path nodes\n        if (flag === false) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node';\n        }\n      }\n    }\n    this.setState({ grid });\n    this.enableExceptClearboard();\n  }\n\n\n\n  handleAlgorithmsDropdown(index) {\n    let algorithmsContainer = document.getElementsByClassName(\"dropdown-container\")[index].style;\n    if (algorithmsContainer.display === \"block\") {\n      algorithmsContainer.display = \"none\";\n    }\n    else {\n      algorithmsContainer.display = \"block\";\n    }\n  }\n\n  handleEachAlgorithmDropdown(algo) {\n    let diagonal = document.getElementById(algo + \"_d\").style;\n    let noDiagonal = document.getElementById(algo + \"_nd\").style;\n    if (diagonal.display === \"block\") {\n      diagonal.display = \"none\";\n    }\n    else {\n      diagonal.display = \"block\";\n    }\n    if (noDiagonal.display === \"block\") {\n      noDiagonal.display = \"none\";\n    }\n    else {\n      noDiagonal.display = \"block\";\n    }\n  }\n\n  // Util functions\n  disableExceptClearboard() {\n    // Disable start & end node\n    const startNode = document.getElementById(\"start_node\");\n    startNode.disabled = true;\n    startNode.style.background = \"white\";\n    const endNode = document.getElementById(\"end_node\");\n    endNode.disabled = true;\n    endNode.style.background = \"white\";\n\n    // Disable all algorithms buttons\n    document.getElementsByClassName(\"dropdown-btn\")[0].style.background = \"white\";\n    const visualizeButtons = document.getElementsByClassName(\"visualize\");\n    for (const button of visualizeButtons) {\n      button.disabled = true;\n    }\n\n    // Disable internal algorithm button\n    document.getElementById(\"bfs_d\").disabled = true;\n    document.getElementById(\"bfs_nd\").disabled = true;\n    document.getElementById(\"dfs_d\").disabled = true;\n    document.getElementById(\"dfs_nd\").disabled = true;\n    document.getElementById(\"dijkstra_d\").disabled = true;\n    document.getElementById(\"dijkstra_nd\").disabled = true;\n    document.getElementById(\"astar_d\").disabled = true;\n    document.getElementById(\"astar_nd\").disabled = true;\n\n    // Disable clear button\n    document.getElementById(\"clear\").disabled = true;\n  }\n  enableExceptClearboard() {\n    // Enable start & end node\n    const startNode = document.getElementById(\"start_node\");\n    startNode.disabled = false;\n    startNode.style.background = \"#111\";\n    const endNode = document.getElementById(\"end_node\");\n    endNode.disabled = false;\n    endNode.style.background = \"#111\";\n\n    // Enable all algorithms buttons\n    document.getElementsByClassName(\"dropdown-btn\")[0].style.background = \"#111\";\n    const visualizeButtons = document.getElementsByClassName(\"visualize\");\n    for (const button of visualizeButtons) {\n      button.disabled = false;\n    }\n\n    // Disable internal algorithm button\n    document.getElementById(\"bfs_d\").disabled = false;\n    document.getElementById(\"bfs_nd\").disabled = false;\n    document.getElementById(\"dfs_d\").disabled = false;\n    document.getElementById(\"dfs_nd\").disabled = false;\n    document.getElementById(\"dijkstra_d\").disabled = false;\n    document.getElementById(\"dijkstra_nd\").disabled = false;\n    document.getElementById(\"astar_d\").disabled = false;\n    document.getElementById(\"astar_nd\").disabled = false;\n\n    // Enable clear button\n    document.getElementById(\"clear\").disabled = false;\n  }\n\n  render() {\n    const { grid } = this.state;\n\n    return (\n      <>\n        <div className=\"sidenav\">\n          <button id=\"start_node\" onClick={() => this.placeStartNode()}>Start Node</button>\n          <button id=\"end_node\" onClick={() => this.placeEndNode()}>End Node</button>\n          <button id=\"wall_node\" onClick={() => this.placeWallNode()} title=\"Click on any cell and then keep moving to create walls. Click again to stop\">Wall Node</button>\n          <button id=\"weight_node\" onClick={() => this.placeWeightNode()} title=\"Click on any cell and then keep moving to create weights. Click again to stop\">Weight Node</button>\n\n          {/* Dropdown of pathfinding algorithms BEGIN */}\n          <button className=\"dropdown-btn\" onClick={() => this.handleAlgorithmsDropdown(0)}>Pathfinding Algorithms<i className=\"fa fa-caret-down\"></i></button>\n          <div className=\"dropdown-container\" id=\"dropdown-container\">\n            {/* BFS */}\n            <button className=\"visualize\" onClick={() => this.handleEachAlgorithmDropdown(\"bfs\")}>Visualize BFS Algorithm</button>\n            <button id=\"bfs_d\" onClick={() => this.visualizeBFS(true)} >Diagonal Movement Allowed</button>\n            <button id=\"bfs_nd\" onClick={() => this.visualizeBFS(false)} >No Diagonal Movement Allowed</button>\n            {/* DFS */}\n            <button className=\"visualize\" onClick={() => this.handleEachAlgorithmDropdown(\"dfs\")}>Visualize DFS Algorithm</button>\n            <button id=\"dfs_d\" onClick={() => this.visualizeDFS(true)} >Diagonal Movement Allowed</button>\n            <button id=\"dfs_nd\" onClick={() => this.visualizeDFS(false)} >No Diagonal Movement Allowed</button>\n            {/* Dijkstra's */}\n            <button className=\"visualize\" onClick={() => this.handleEachAlgorithmDropdown(\"dijkstra\")}>Visualize Dijkstra's Algorithm</button>\n            <button id=\"dijkstra_d\" onClick={() => this.visualizeDijkstra(true)} >Diagonal Movement Allowed</button>\n            <button id=\"dijkstra_nd\" onClick={() => this.visualizeDijkstra(false)} >No Diagonal Movement Allowed</button>\n            {/* A* Search */}\n            <button className=\"visualize\" onClick={() => this.handleEachAlgorithmDropdown(\"astar\")}>Visualize A* Search Algorithm</button>\n            <button id=\"astar_d\" onClick={() => this.visualizeAStar(true)} >Diagonal Movement Allowed</button>\n            <button id=\"astar_nd\" onClick={() => this.visualizeAStar(false)} >No Diagonal Movement Allowed</button>\n          </div>\n          {/* Dropdown of pathfinding algorithms END */}\n\n          {/* Dropdown of maze algorithms BEGIN */}\n          <button className=\"dropdown-btn\" onClick={() => this.handleAlgorithmsDropdown(1)}>Maze Algorithms<i className=\"fa fa-caret-down\"></i></button>\n          <div className=\"dropdown-container\" id=\"dropdown-container\">\n            {/* Randomized DFS */}\n            <button className=\"visualize\" onClick={() => this.visualizeDFSMaze()}>Visualize Randomized DFS Algorithm</button>\n            {/* Recursive Division */}\n            <button className=\"visualize\" onClick={() => this.visualizeRecursiveDivision()}>Visualize Recursive Division Algorithm</button>\n          </div>\n          {/* Dropdown of maze algorithms END */}\n\n          <button id=\"clear\" onClick={() => this.clearBoard()}>Clear Board</button>\n          <button id=\"prevGrid\" onClick={() => this.getPrevBoard()}>Use Previous Board</button>\n          <button id=\"stopAnimating\">Stop Animation</button>\n          <button id=\"pauseAnimating\">Pause Animation</button>\n          <button id=\"playAnimating\">Play Animation</button>\n        </div>\n\n\n        <div className=\"main info\">\n          Adding WALL on cell makes it <strong>impenetrable</strong> <br></br>\n          Adding WEIGHT on cell <strong>increases</strong> the cost to pass throught it. Here the cost is multiplied 10 times.\n        </div>\n\n        <div className=\"grid main\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isEnd, isStart, isWall, isWeight } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isEnd={isEnd}\n                      isStart={isStart}\n                      isWall={isWall}\n                      isWeight={isWeight}\n                      onMouseClick={(row, col) => this.handleMouseClick(row, col)}\n                      onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n\n  // Pathfinding Algorithms Helper Functions\n  refreshBoardForPathfinding(currGrid) {\n    // Defaults visited & distance of each node. Need this before\n    // running the pathfinding algorithms\n    const grid = currGrid.slice();\n    for (const row of grid) {\n      for (const node of row) {\n        node.distance = Infinity;\n        node.isVisited = false;\n      }\n    }\n    return grid;\n  }\n  visualizeDijkstra(diagonal) {\n    if (START_NODE_ROW == -1 || START_NODE_COL == -1) {\n      alert(\"start node isn't selected\");\n      return;\n    }\n    if (FINISH_NODE_ROW == -1 || FINISH_NODE_COL == -1) {\n      alert(\"end node isn't selected\");\n    }\n    document.getElementsByClassName(\"info\")[0].innerHTML =\n      \"Dijkstra's Algorithm is <strong>weighted</strong> algorithm and <strong>guarentees</strong> shortest path\";\n    this.disableExceptClearboard();\n    let { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    grid = this.refreshBoardForPathfinding(grid);\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode, diagonal);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n  }\n  visualizeBFS(diagonal) {\n    if (START_NODE_ROW == -1 || START_NODE_COL == -1) {\n      alert(\"start node isn't selected\");\n      return;\n    }\n    if (FINISH_NODE_ROW == -1 || FINISH_NODE_COL == -1) {\n      alert(\"end node isn't selected\");\n    }\n    document.getElementsByClassName(\"info\")[0].innerHTML =\n      \"Breadth First Search Algorithm is <strong>unweighted</strong> algorithm and <strong>guarentees</strong> shortest path\";\n    this.disableExceptClearboard();\n    let { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    grid = this.refreshBoardForPathfinding(grid);\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode, diagonal);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n  }\n  visualizeDFS(diagonal) {\n    if (START_NODE_ROW == -1 || START_NODE_COL == -1) {\n      alert(\"start node isn't selected\");\n      return;\n    }\n    if (FINISH_NODE_ROW == -1 || FINISH_NODE_COL == -1) {\n      alert(\"end node isn't selected\");\n    }\n    document.getElementsByClassName(\"info\")[0].innerHTML =\n      \"Depth First Search Algorithm is <strong>unweighted</strong> algorithm and <strong>doesn't</strong> guarentees shortest path\";\n    this.disableExceptClearboard();\n    let { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    grid = this.refreshBoardForPathfinding(grid);\n    const visitedNodesInOrder = dfs(grid, startNode, finishNode, diagonal);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n  }\n  visualizeAStar(diagonal) {\n    if (START_NODE_ROW == -1 || START_NODE_COL == -1) {\n      alert(\"start node isn't selected\");\n      return;\n    }\n    if (FINISH_NODE_ROW == -1 || FINISH_NODE_COL == -1) {\n      alert(\"end node isn't selected\");\n    }\n    document.getElementsByClassName(\"info\")[0].innerHTML =\n      \"A* Search Algorithm is <strong>weighted</strong> algorithm and <strong>guarentees</strong> shortest path<br></br><strong>Faster</strong> than Dijkstra's since it uses <strong>Heuristics</strong>\";\n    this.disableExceptClearboard();\n    let { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    grid = this.refreshBoardForPathfinding(grid);\n    const visitedNodesInOrder = astar(grid, startNode, finishNode, diagonal);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n  }\n  animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode) {\n    let i = 1;\n    let animatingShortestPath = this.animateShortestPath;\n    let enableExceptClearboard = this.enableExceptClearboard;\n    function animate() {\n      if (stopAnimating) {\n        enableExceptClearboard();\n        return;\n      }\n\n      if (i == visitedNodesInOrder.length - 1) {\n        console.log(\"animating shortest path\");\n        animatingShortestPath(nodesInShortestPathOrder, enableExceptClearboard);\n        document.getElementById(\"clear\").disabled = false;\n        return;\n      }\n\n      const node = visitedNodesInOrder[i];\n      if (!(node.row === START_NODE_ROW && node.col === START_NODE_COL) || (node.row === FINISH_NODE_ROW && node.col === FINISH_NODE_COL)) {\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n      }\n      i++;\n      requestAnimationFrame(animate);\n    }\n    animate();\n  }\n\n  animateShortestPath(nodesInShortestPathOrder, enableExceptClearboard) {\n    const firstNodeInShortestPath = nodesInShortestPathOrder[0];\n    if (!(firstNodeInShortestPath.row === START_NODE_ROW && firstNodeInShortestPath.col === START_NODE_COL)) {\n      alert(\"No Shortest Path\");\n      return;\n    }\n    const node = nodesInShortestPathOrder[0];\n    document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path node-start';\n\n    let i = 1;\n    function animate() {\n      if (stopAnimating) {\n        enableExceptClearboard();\n        return;\n      }\n      const node = nodesInShortestPathOrder[i];\n      if (i == nodesInShortestPathOrder.length - 1) {\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path node-finish';\n        return;\n      }\n      else {\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n      }\n      i++;\n\n      requestAnimationFrame(animate);\n    }\n    animate();\n  }\n\n  refreshBoardForMaze(currGrid) {\n    let grid = currGrid.slice();\n    for (const row of grid) {\n      for (const node of row) {\n        node.isVisited = false;\n        node.isWall = false;\n      }\n    }\n    return grid;\n  }\n\n\n  visualizeDFSMaze() {\n    // this.clearBoard();\n    //21*51 board\n    let { grid } = this.state;\n    grid = this.refreshBoardForMaze(grid);\n    let start_x = getRandomInteger(0, HEIGHT);\n    let start_y = getRandomInteger(0, WIDTH);\n    while (start_x % 2 != 0) {\n      start_x = getRandomInteger(0, HEIGHT);\n    }\n    while (start_y % 2 != 0) {\n      start_y = getRandomInteger(0, WIDTH);\n    }\n    const visitedNodesInOrder = dfsMaze(grid, start_x, start_y);\n    this.animateMaze(visitedNodesInOrder);\n  }\n\n  visualizeRecursiveDivision() {\n    let { grid } = this.state;\n    const visitedNodesInOrder = recursiveDivision(grid);\n    this.animateMaze(visitedNodesInOrder);\n  }\n\n  animateMaze(visitedNodesInOrder) {\n    let i = 1;\n    let enableExceptClearboard = this.enableExceptClearboard;\n    function animate() {\n      if (stopAnimating) {\n        enableExceptClearboard();\n        return;\n      }\n\n      const node = visitedNodesInOrder[i];\n      document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall';\n      i++;\n      requestAnimationFrame(animate);\n    }\n    animate();\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row <= HEIGHT; row++) {\n    const currentRow = [];\n    for (let col = 0; col <= WIDTH; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: false,\n    isEnd: false,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    isWeight: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  // This node has isWall=True which makes its className='node-wall' whose color is black as specified in the styling\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithStartToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  // This node has isStart=True which makes its className='node-start' whose color is specified in the styling\n  const newNode = {\n    ...node,\n    isStart: !node.isStart,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithEndToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  // This node has isEnd=True which makes its className='node-end' whose color is specified in the styling\n  const newNode = {\n    ...node,\n    isEnd: !node.isEnd,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithWeightToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWeight: !node.isWeight,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n}\n\n","export function bfs(grid, startNode, endNode, diagonal) {\r\n    const visitedNodesInOrder = [];\r\n    const queue = [];\r\n    queue.push(startNode);\r\n    startNode.isVisited = true;\r\n    visitedNodesInOrder.push(startNode);\r\n    while (queue.length != 0) {\r\n        const node = queue.shift();\r\n        if (node === endNode) return visitedNodesInOrder;\r\n        const side_nodes_x = [0, 0, 1, -1];\r\n        const side_nodes_y = [1, -1, 0, 0];\r\n\r\n        for (let i = 0; i < 4; ++i) {\r\n            const { col, row } = node;\r\n            const new_x = row + side_nodes_x[i];\r\n            const new_y = col + side_nodes_y[i];\r\n            if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\r\n            const neighbor = grid[new_x][new_y];\r\n            if (neighbor.isVisited == true || neighbor.isWall == true) continue;\r\n            neighbor.isVisited = true;\r\n            queue.push(neighbor);\r\n            visitedNodesInOrder.push(neighbor);\r\n            neighbor.previousNode = node;\r\n        }\r\n\r\n        if (diagonal === true) {\r\n            const diagonal_nodes_x = [1, 1, -1, -1];\r\n            const diagonal_nodes_y = [1, -1, 1, -1];\r\n\r\n            for (let i = 0; i < 4; ++i) {\r\n                const { col, row } = node;\r\n                const new_x = row + diagonal_nodes_x[i];\r\n                const new_y = col + diagonal_nodes_y[i];\r\n                if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\r\n                const neighbor = grid[new_x][new_y];\r\n                if (neighbor.isVisited == true || neighbor.isWall == true) continue;\r\n                neighbor.isVisited = true;\r\n                queue.push(neighbor);\r\n                visitedNodesInOrder.push(neighbor);\r\n                neighbor.previousNode = node;\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}