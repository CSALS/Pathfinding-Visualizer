{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingAlgorithms/dijkstra.js","PathfindingAlgorithms/dfs.js","MazeAlgorithms/dfsMaze.js","PathfindingVisualizer/PathfindingVisualizer.jsx","PathfindingAlgorithms/bfs.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","row","col","isEnd","isStart","isWall","isWeight","onMouseClick","onMouseEnter","extraClassName","id","className","onClick","Component","dijkstra","grid","startNode","finishNode","diagonal","visitedNodesInOrder","distance","allNodes","nodes","node","push","getAllNodes","iterations","length","closestNode","getClosestUnvisitedNode","Infinity","isVisited","side_nodes_x","side_nodes_y","i","new_x","new_y","neighbor","previousNode","diagonal_nodes_x","diagonal_nodes_y","minDistance","console","log","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","dfs","endNode","dfsRecursive","dfsMaze","start_x","start_y","start_node","dfsMazeUtil","x","y","array","j","Math","floor","random","side_nodes_x1","side_nodes_y1","side_nodes_x2","side_nodes_y2","stack_child","k","new_x2","new_y2","new_x1","new_y1","childNode","pop","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","state","isPlaceStart","isPlaceEnd","isPlaceWeight","isPlaceWall","startPresent","endPresent","isMousePressed","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","getNewGridWithWeightToggled","isSameNode","getNewGridWithStartToggled","getNewGridWithEndToggled","document","getElementById","enableExceptClearboard","algorithmsContainer","getElementsByClassName","style","display","algo","noDiagonal","disabled","background","visualizeButtons","placeStartNode","placeEndNode","placeWallNode","title","placeWeightNode","handleAlgorithmsDropdown","handleEachAlgorithmDropdown","visualizeBFS","visualizeDFS","visualizeDijkstra","visualizeAStar","clearBoard","genRandomBoard","getPrevBoard","map","rowIdx","key","nodeIdx","handleMouseClick","handleMouseEnter","currGrid","slice","alert","innerHTML","disableExceptClearboard","refreshBoardForPathfinding","animateVisitedNodes","queue","shift","bfs","setTimeout","animateShortestPath","firstNodeInShortestPath","refreshBoardForMaze","getRandomInteger","currentRow","createNode","newNode","min","max","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e101e90f.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      row, col,\n      isEnd,\n      isStart,\n      isWall,\n      isWeight,\n      onMouseClick,\n      onMouseEnter,\n    } = this.props;\n\n    const extraClassName = isEnd ? 'node-finish' : isStart ? 'node-start' : isWall ? 'node-wall' : isWeight ? 'node-weight' : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onClick={() => onMouseClick(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n      >\n      </div>\n    );\n  }\n}\n","// visitedNodesInOrder = Stores the order in which nodes are visited\n\n\nexport function dijkstra(grid, startNode, finishNode, diagonal) {\n\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const allNodes = getAllNodes(grid);\n  let iterations = allNodes.length;\n  while (iterations--) {\n    // Get the node with minimum distance and not visited\n    const closestNode = getClosestUnvisitedNode(allNodes);\n\n    if (closestNode === null) return visitedNodesInOrder;\n\n    // If this closest node distance is Infinity then we are trapped\n    // so we stop and return the nodes visited till now\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n    // Push this closestNode in the visited nodes array and make it visited as true\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n\n    // If the closestNode is the finishNode which is the target we are done\n    // so return the nodes visited\n    if (closestNode === finishNode) return visitedNodesInOrder;\n\n    // Update the distance of the neighbours of the closestNode\n    const side_nodes_x = [0, 0, 1, -1];\n    const side_nodes_y = [1, -1, 0, 0];\n\n    for (let i = 0; i < 4; ++i) {\n      const { col, row } = closestNode;\n      const new_x = row + side_nodes_x[i];\n      const new_y = col + side_nodes_y[i];\n      if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\n      const neighbor = grid[new_x][new_y];\n      if (neighbor.isVisited == true || neighbor.isWall == true) continue;\n      if (closestNode.distance + 1 < neighbor.distance) {\n        neighbor.distance = closestNode.distance + 1;\n        if (neighbor.isWeight) neighbor.distance *= 2;\n        neighbor.previousNode = closestNode;\n      }\n    }\n    if (diagonal === true) {\n      const diagonal_nodes_x = [1, 1, -1, -1];\n      const diagonal_nodes_y = [1, -1, 1, -1];\n\n      for (let i = 0; i < 4; ++i) {\n        const { col, row } = closestNode;\n        const new_x = row + diagonal_nodes_x[i];\n        const new_y = col + diagonal_nodes_y[i];\n        if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\n        const neighbor = grid[new_x][new_y];\n        if (neighbor.isVisited == true || neighbor.isWall == true) continue;\n        if (closestNode.distance + 1.2 < neighbor.distance) {\n          neighbor.distance = closestNode.distance + 1.2;\n          if (neighbor.isWeight) neighbor.distance *= 2;\n          neighbor.previousNode = closestNode;\n        }\n      }\n    }\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction getClosestUnvisitedNode(allNodes) {\n  let closestNode = null;\n  let minDistance = Infinity;\n  for (const node of allNodes) {\n    // console.log(node)\n    if (node.isVisited == true || node.isWall == true) continue;\n    if (node.distance < minDistance) {\n      closestNode = node;\n      minDistance = node.distance;\n    }\n  }\n  console.log(closestNode);\n  return closestNode;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the pathfinding algorithm is called above.\n// This method is same for any algorithm\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","export function dfs(grid, startNode, endNode, diagonal) {\r\n    const visitedNodesInOrder = [];\r\n    dfsRecursive(grid, startNode, endNode, visitedNodesInOrder, diagonal);\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction dfsRecursive(grid, node, endNode, visitedNodesInOrder, diagonal) {\r\n    node.isVisited = true;\r\n    visitedNodesInOrder.push(node);\r\n\r\n    if (node === endNode) return true;\r\n\r\n    const side_nodes_x = [0, 0, 1, -1];\r\n    const side_nodes_y = [1, -1, 0, 0];\r\n\r\n    for (let i = 0; i < 4; ++i) {\r\n        const { col, row } = node;\r\n        const new_x = row + side_nodes_x[i];\r\n        const new_y = col + side_nodes_y[i];\r\n        if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\r\n        const neighbor = grid[new_x][new_y];\r\n        if (neighbor.isVisited === true || neighbor.isWall === true) continue;\r\n        neighbor.previousNode = node;\r\n        if (dfsRecursive(grid, neighbor, endNode, visitedNodesInOrder, diagonal)) return true;\r\n    }\r\n    if (diagonal === true) {\r\n        const diagonal_nodes_x = [1, 1, -1, -1];\r\n        const diagonal_nodes_y = [1, -1, 1, -1];\r\n\r\n        for (let i = 0; i < 4; ++i) {\r\n            const { col, row } = node;\r\n            const new_x = row + diagonal_nodes_x[i];\r\n            const new_y = col + diagonal_nodes_y[i];\r\n            if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\r\n            const neighbor = grid[new_x][new_y];\r\n            if (neighbor.isVisited === true || neighbor.isWall === true) continue;\r\n            neighbor.previousNode = node;\r\n            if (dfsRecursive(grid, neighbor, endNode, visitedNodesInOrder, diagonal)) return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n\r\n}","export function dfsMaze(grid, start_x, start_y) {\r\n    const start_node = grid[start_x][start_y];\r\n    start_node.isVisited = true;\r\n    start_node.isWall = true;\r\n    const visitedNodesInOrder = [start_node];\r\n    console.log(start_x, start_y);\r\n    dfsMazeUtil(grid, start_x, start_y, visitedNodesInOrder);\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n\r\nfunction dfsMazeUtil(grid, x, y, visitedNodesInOrder) {\r\n    const node = grid[x][y];\r\n    // Shuffling indexes\r\n    const array = [0, 1, 2, 3];\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    console.log(array);\r\n    const side_nodes_x1 = [0, 0, 1, -1];\r\n    const side_nodes_y1 = [1, -1, 0, 0];\r\n    const side_nodes_x2 = [0, 0, 2, -2];\r\n    const side_nodes_y2 = [2, -2, 0, 0];\r\n    const stack_child = [];\r\n    for (let k = 0; k <= 3; ++k) {\r\n        const i = array[k];\r\n        const { col, row } = node;\r\n        const new_x2 = row + side_nodes_x2[i];\r\n        const new_y2 = col + side_nodes_y2[i];\r\n        if (!(new_x2 >= 0 && new_y2 >= 0 && new_x2 < grid.length && new_y2 < grid[0].length)) continue;\r\n        const neighbor = grid[new_x2][new_y2];\r\n        if (neighbor.isVisited === true || neighbor.isWall === true) continue;\r\n        const new_x1 = row + side_nodes_x1[i];\r\n        const new_y1 = col + side_nodes_y1[i];\r\n        if ((new_x1 >= 0 && new_y1 >= 0 && new_x1 < grid.length && new_y1 < grid[0].length)) {\r\n            grid[new_x1][new_y1].isWall = true;\r\n            grid[new_x1][new_y1].isVisited = true;\r\n            visitedNodesInOrder.push(grid[new_x1][new_y1]);\r\n        }\r\n        stack_child.push({ 'x': new_x2, 'y': new_y2 });\r\n        const childNode = grid[new_x2][new_y2];\r\n        childNode.isVisited = true;\r\n        childNode.isWall = true;\r\n        visitedNodesInOrder.push(grid[new_x2][new_y2]);\r\n        // dfsMazeUtil(grid, new_x2, new_y2, visitedNodesInOrder);\r\n    }\r\n    // console.log(stack_child)\r\n    while (stack_child.length != 0) {\r\n        const node = stack_child.pop();\r\n        dfsMazeUtil(grid, node['x'], node['y'], visitedNodesInOrder);\r\n    }\r\n}","import React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra, getNodesInShortestPathOrder } from '../PathfindingAlgorithms/dijkstra';\nimport { bfs } from '../PathfindingAlgorithms/bfs';\nimport { dfs } from '../PathfindingAlgorithms/dfs';\nimport { dfsMaze } from '../MazeAlgorithms/dfsMaze';\n\nimport './PathfindingVisualizer.css';\n\nvar START_NODE_ROW = -1;\nvar START_NODE_COL = -1;\nvar FINISH_NODE_ROW = -1;\nvar FINISH_NODE_COL = -1;\nvar TIME_INTERVAL = 25;\nvar HEIGHT = 20;\nvar WIDTH = 50;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      isPlaceStart: false,\n      isPlaceEnd: false,\n      isPlaceWeight: false,\n      isPlaceWall: false,\n      startPresent: false,\n      endPresent: false,\n      isMousePressed: false,\n    };\n  }\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid: grid });\n  }\n  placeStartNode() {\n    this.setState({ isPlaceStart: true });\n  }\n  placeEndNode() {\n    this.setState({ isPlaceEnd: true });\n  }\n  placeWallNode() {\n    this.setState({ isPlaceWall: true });\n  }\n  placeWeightNode() {\n    this.setState({ isPlaceWeight: true });\n  }\n\n  handleMouseClick(row, col) {\n    console.log(\"A cell is clicked\")\n    const { isPlaceStart, isPlaceEnd, endPresent, startPresent, isMousePressed, isPlaceWeight, isPlaceWall } = this.state;\n    let newGrid = null;\n    if (isMousePressed) {\n      console.log(\"Back to normal state\");\n      this.setState({ isMousePressed: false, isPlaceWall: false, isPlaceWeight: false });\n      return;\n    }\n    else if (isPlaceWall) {\n      console.log(\"Placing wall node\");\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ isMousePressed: true });\n    }\n    else if (isPlaceWeight) {\n      newGrid = getNewGridWithWeightToggled(this.state.grid, row, col);\n      this.setState({ isMousePressed: true });\n    }\n    else if (isPlaceStart) {\n      const isSameNode = (row == START_NODE_ROW && col == START_NODE_COL)\n      if (!isSameNode && startPresent) {\n        console.log(\"Start Node already present\");\n        return;\n      }\n\n      newGrid = getNewGridWithStartToggled(this.state.grid, row, col);\n      START_NODE_ROW = row;\n      START_NODE_COL = col;\n      if (isSameNode) {\n        this.setState({ startPresent: false });\n      }\n      else {\n        this.setState({ startPresent: true });\n      }\n    }\n    else if (isPlaceEnd) {\n      const isSameNode = (row == FINISH_NODE_ROW && col == FINISH_NODE_COL);\n      if (!isSameNode && endPresent) {\n        console.log(\"End Node already present\");\n        return;\n      }\n\n      newGrid = getNewGridWithEndToggled(this.state.grid, row, col);\n      FINISH_NODE_ROW = row;\n      FINISH_NODE_COL = col;\n      if (isSameNode) {\n        this.setState({ endPresent: false });\n      }\n      else {\n        this.setState({ endPresent: true });\n      }\n    }\n\n    if (newGrid === null) {\n      console.log(\"Error in handling mouse click\");\n      return;\n    }\n    this.setState({ grid: newGrid, isPlaceStart: false, isPlaceEnd: false });\n  }\n\n  handleMouseEnter(row, col) {\n    const { isPlaceStart, isPlaceEnd, isMousePressed, isPlaceWeight, isPlaceWall, startPresent, endPresent } = this.state;\n    if (isPlaceEnd || isPlaceStart) {\n      console.log(\"Placing start or end node.Cant drag\");\n      return;\n    }\n    if (!isMousePressed) {\n      console.log(\"Mouse is not being dragged\");\n      return;\n    }\n    if (startPresent && row == START_NODE_ROW && col == START_NODE_COL) {\n      console.log(\"start present on that cell.cant place wall\")\n      return;\n    }\n    if (endPresent && row == FINISH_NODE_ROW && col == FINISH_NODE_COL) {\n      console.log(\"end present on that cell.cant place wall\")\n      return;\n    }\n    let newGrid = null;\n    if (isPlaceWall) {\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid });\n    }\n    else if (isPlaceWeight) {\n      newGrid = getNewGridWithWeightToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid });\n    }\n  }\n\n  clearBoard() {\n    const grid = getInitialGrid();\n    for (let row = 0; row < grid.length; ++row) {\n      for (let col = 0; col < grid[0].length; ++col) {\n        document.getElementById(`node-${row}-${col}`).className = 'node';\n      }\n    }\n    this.setState({\n      grid: grid, isPlaceStart: false,\n      isPlaceEnd: false,\n      isPlaceWeight: false,\n      isPlaceWall: false,\n      startPresent: false,\n      endPresent: false,\n      isMousePressed: false,\n    });\n    this.enableExceptClearboard();\n    START_NODE_ROW = -1;\n    START_NODE_COL = -1;\n    FINISH_NODE_ROW = -1;\n    FINISH_NODE_COL = -1;\n  }\n\n  getPrevBoard() {\n    console.log(\"TODO: Implement use previous board function\");\n  }\n\n\n\n  handleAlgorithmsDropdown() {\n    let algorithmsContainer = document.getElementsByClassName(\"dropdown-container\")[0].style;\n    if (algorithmsContainer.display === \"block\") {\n      algorithmsContainer.display = \"none\";\n    }\n    else {\n      algorithmsContainer.display = \"block\";\n    }\n  }\n\n  handleEachAlgorithmDropdown(algo) {\n    let diagonal = document.getElementById(algo + \"_d\").style;\n    let noDiagonal = document.getElementById(algo + \"_nd\").style;\n    if (diagonal.display === \"block\") {\n      diagonal.display = \"none\";\n    }\n    else {\n      diagonal.display = \"block\";\n    }\n    if (noDiagonal.display === \"block\") {\n      noDiagonal.display = \"none\";\n    }\n    else {\n      noDiagonal.display = \"block\";\n    }\n  }\n\n  // Util functions\n  disableExceptClearboard() {\n    // Disable start & end node\n    const startNode = document.getElementById(\"start_node\");\n    startNode.disabled = true;\n    startNode.style.background = \"white\";\n    const endNode = document.getElementById(\"end_node\");\n    endNode.disabled = true;\n    endNode.style.background = \"white\";\n\n    // Disable all algorithms buttons\n    document.getElementsByClassName(\"dropdown-btn\")[0].style.background = \"white\";\n    const visualizeButtons = document.getElementsByClassName(\"visualize\");\n    for (const button of visualizeButtons) {\n      button.disabled = true;\n    }\n\n    // Disable internal algorithm button\n    document.getElementById(\"bfs_d\").disabled = true;\n    document.getElementById(\"bfs_nd\").disabled = true;\n    document.getElementById(\"dfs_d\").disabled = true;\n    document.getElementById(\"dfs_nd\").disabled = true;\n    document.getElementById(\"dijkstra_d\").disabled = true;\n    document.getElementById(\"dijkstra_nd\").disabled = true;\n    document.getElementById(\"astar_d\").disabled = true;\n    document.getElementById(\"astar_nd\").disabled = true;\n\n    // Disable clear button\n    document.getElementById(\"clear\").disabled = true;\n  }\n  enableExceptClearboard() {\n    // Enable start & end node\n    const startNode = document.getElementById(\"start_node\");\n    startNode.disabled = false;\n    startNode.style.background = \"#111\";\n    const endNode = document.getElementById(\"end_node\");\n    endNode.disabled = false;\n    endNode.style.background = \"#111\";\n\n    // Enable all algorithms buttons\n    document.getElementsByClassName(\"dropdown-btn\")[0].style.background = \"#111\";\n    const visualizeButtons = document.getElementsByClassName(\"visualize\");\n    for (const button of visualizeButtons) {\n      button.disabled = false;\n    }\n\n    // Disable internal algorithm button\n    document.getElementById(\"bfs_d\").disabled = false;\n    document.getElementById(\"bfs_nd\").disabled = false;\n    document.getElementById(\"dfs_d\").disabled = false;\n    document.getElementById(\"dfs_nd\").disabled = false;\n    document.getElementById(\"dijkstra_d\").disabled = false;\n    document.getElementById(\"dijkstra_nd\").disabled = false;\n    document.getElementById(\"astar_d\").disabled = false;\n    document.getElementById(\"astar_nd\").disabled = false;\n\n    // Enable clear button\n    document.getElementById(\"clear\").disabled = false;\n  }\n\n  render() {\n    const { grid } = this.state;\n\n    return (\n      <>\n        <div className=\"sidenav\">\n          <button id=\"start_node\" onClick={() => this.placeStartNode()}>Start Node</button>\n          <button id=\"end_node\" onClick={() => this.placeEndNode()}>End Node</button>\n          <button id=\"wall_node\" onClick={() => this.placeWallNode()} title=\"Click on any cell and then keep moving to create walls. Click again to stop\">Wall Node</button>\n          <button id=\"weight_node\" onClick={() => this.placeWeightNode()} title=\"Click on any cell and then keep moving to create weights. Click again to stop\">Weight Node</button>\n          <button className=\"dropdown-btn\" onClick={() => this.handleAlgorithmsDropdown()}>Algorithms<i className=\"fa fa-caret-down\"></i></button>\n          <div className=\"dropdown-container\" id=\"dropdown-container\">\n            {/* BFS */}\n            <button className=\"visualize\" onClick={() => this.handleEachAlgorithmDropdown(\"bfs\")}>Visualize BFS Algorithm</button>\n            <button id=\"bfs_d\" onClick={() => this.visualizeBFS(true)} >Diagonal Movement Allowed</button>\n            <button id=\"bfs_nd\" onClick={() => this.visualizeBFS(false)} >No Diagonal Movement Allowed</button>\n            {/* DFS */}\n            <button className=\"visualize\" onClick={() => this.handleEachAlgorithmDropdown(\"dfs\")}>Visualize DFS Algorithm</button>\n            <button id=\"dfs_d\" onClick={() => this.visualizeDFS(true)} >Diagonal Movement Allowed</button>\n            <button id=\"dfs_nd\" onClick={() => this.visualizeDFS(false)} >No Diagonal Movement Allowed</button>\n            {/* Dijkstra's */}\n            <button className=\"visualize\" onClick={() => this.handleEachAlgorithmDropdown(\"dijkstra\")}>Visualize Dijkstra's Algorithm</button>\n            <button id=\"dijkstra_d\" onClick={() => this.visualizeDijkstra(true)} >Diagonal Movement Allowed</button>\n            <button id=\"dijkstra_nd\" onClick={() => this.visualizeDijkstra(false)} >No Diagonal Movement Allowed</button>\n            {/* A* Search */}\n            <button className=\"visualize\" onClick={() => this.handleEachAlgorithmDropdown(\"astar\")}>Visualize A* Search Algorithm</button>\n            <button id=\"astar_d\" onClick={() => this.visualizeAStar(true)} >Diagonal Movement Allowed</button>\n            <button id=\"astar_nd\" onClick={() => this.visualizeAStar(false)} >No Diagonal Movement Allowed</button>\n          </div>\n          <button id=\"clear\" onClick={() => this.clearBoard()}>Clear Board</button>\n          <button id=\"randomBoard\" onClick={() => this.genRandomBoard()}>Generate random board</button>\n          <button id=\"prevGrid\" onClick={() => this.getPrevBoard()}>Use Previous Board</button>\n        </div>\n\n\n        <div className=\"main info\">\n          Adding WALL on cell makes it <strong>impenetrable</strong> <br></br>\n          Adding WEIGHT on cell <strong>increases</strong> the cost to pass throught it. Here the cost is doubled\n        </div>\n\n        <div className=\"grid main\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isEnd, isStart, isWall, isWeight } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isEnd={isEnd}\n                      isStart={isStart}\n                      isWall={isWall}\n                      isWeight={isWeight}\n                      onMouseClick={(row, col) => this.handleMouseClick(row, col)}\n                      onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n\n  // Pathfinding Algorithms Helper FUnctions\n  refreshBoardForPathfinding(currGrid) {\n    // Defaults visited & distance of each node. Need this before\n    // running the pathfinding algorithms\n    const grid = currGrid.slice();\n    for (const row of grid) {\n      for (const node of row) {\n        node.distance = Infinity;\n        node.isVisited = false;\n      }\n    }\n    return grid;\n  }\n  visualizeDijkstra(diagonal) {\n    if (START_NODE_ROW == -1 || START_NODE_COL == -1) {\n      alert(\"start node isn't selected\");\n      return;\n    }\n    if (FINISH_NODE_ROW == -1 || FINISH_NODE_COL == -1) {\n      alert(\"end node isn't selected\");\n    }\n    document.getElementsByClassName(\"info\")[0].innerHTML =\n      \"Dijkstra's Algorithm is <strong>weighted</strong> algorithm and <strong>guarentees</strong> shortest path\";\n    this.disableExceptClearboard();\n    let { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    grid = this.refreshBoardForPathfinding(grid);\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode, diagonal);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    // console.log(visitedNodesInOrder);\n    // console.log(nodesInShortestPathOrder);\n    this.animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n  }\n  visualizeBFS(diagonal) {\n    if (START_NODE_ROW == -1 || START_NODE_COL == -1) {\n      alert(\"start node isn't selected\");\n      return;\n    }\n    if (FINISH_NODE_ROW == -1 || FINISH_NODE_COL == -1) {\n      alert(\"end node isn't selected\");\n    }\n    document.getElementsByClassName(\"info\")[0].innerHTML =\n      \"Breadth First Search Algorithm is <strong>unweighted</strong> algorithm and <strong>guarentees</strong> shortest path\";\n    this.disableExceptClearboard();\n    let { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    grid = this.refreshBoardForPathfinding(grid);\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode, diagonal);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    // console.log(visitedNodesInOrder);\n    // console.log(nodesInShortestPathOrder);\n    this.animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n  }\n  visualizeDFS(diagonal) {\n    if (START_NODE_ROW == -1 || START_NODE_COL == -1) {\n      alert(\"start node isn't selected\");\n      return;\n    }\n    if (FINISH_NODE_ROW == -1 || FINISH_NODE_COL == -1) {\n      alert(\"end node isn't selected\");\n    }\n    document.getElementsByClassName(\"info\")[0].innerHTML =\n      \"Depth First Search Algorithm is <strong>unweighted</strong> algorithm and <strong>doesn't</strong> guarentees shortest path\";\n    this.disableExceptClearboard();\n    let { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    grid = this.refreshBoardForPathfinding(grid);\n    const visitedNodesInOrder = dfs(grid, startNode, finishNode, diagonal);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    // console.log(visitedNodesInOrder);\n    // console.log(nodesInShortestPathOrder);\n    this.animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n  }\n  animateVisitedNodes(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode) {\n    for (let i = 1; i <= visitedNodesInOrder.length - 1; i++) {\n      if (i === visitedNodesInOrder.length - 1) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n          // Enable clear button\n          document.getElementById(\"clear\").disabled = false;\n        }, TIME_INTERVAL * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node === startNode || node === finishNode) return;\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, TIME_INTERVAL * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    const firstNodeInShortestPath = nodesInShortestPathOrder[0];\n    if (!(firstNodeInShortestPath.row === START_NODE_ROW && firstNodeInShortestPath.col === START_NODE_COL)) {\n      setTimeout(() => {\n        alert(\"No Shortest Path\");\n      }, TIME_INTERVAL)\n      return;\n    }\n    const node = nodesInShortestPathOrder[0];\n    document.getElementById(`node-${node.row}-${node.col}`).className =\n      'node node-shortest-path node-start';\n\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if (i == nodesInShortestPathOrder.length - 1) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-shortest-path node-finish';\n        }\n        else {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-shortest-path';\n        }\n      }, 2 * TIME_INTERVAL * i);\n    }\n  }\n\n  refreshBoardForMaze(currGrid) {\n    let grid = currGrid.slice();\n    for (const row of grid) {\n      for (const node of row) {\n        node.isVisited = false;\n        node.isWall = false;\n      }\n    }\n    return grid;\n  }\n\n\n  genRandomBoard() {\n    // this.clearBoard();\n    //21*51 board\n    let { grid } = this.state;\n    grid = this.refreshBoardForMaze(grid);\n    let start_x = getRandomInteger(0, HEIGHT);\n    let start_y = getRandomInteger(0, WIDTH);\n    while (start_x % 2 != 0) {\n      start_x = getRandomInteger(0, HEIGHT);\n    }\n    while (start_y % 2 != 0) {\n      start_y = getRandomInteger(0, WIDTH);\n    }\n    const visitedNodesInOrder = dfsMaze(grid, start_x, start_y);\n    grid = this.refreshBoardForMaze(grid);\n    for (let i = 0; i < visitedNodesInOrder.length; ++i) {\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        node.isWall = true;\n        this.setState({ grid });\n      }, 0);\n    }\n    this.setState({ grid });\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row <= HEIGHT; row++) {\n    const currentRow = [];\n    for (let col = 0; col <= WIDTH; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: false,\n    isEnd: false,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    isWeight: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  // This node has isWall=True which makes its className='node-wall' whose color is black as specified in the styling\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithStartToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  // This node has isStart=True which makes its className='node-start' whose color is specified in the styling\n  const newNode = {\n    ...node,\n    isStart: !node.isStart,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithEndToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  // This node has isEnd=True which makes its className='node-end' whose color is specified in the styling\n  const newNode = {\n    ...node,\n    isEnd: !node.isEnd,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithWeightToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWeight: !node.isWeight,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n}\n\nconst getRandomInteger = (min, max) => {\n  return Math.floor(Math.random() * (max - min)) + min;\n}","export function bfs(grid, startNode, endNode, diagonal) {\r\n    const visitedNodesInOrder = [];\r\n    const queue = [];\r\n    queue.push(startNode);\r\n    startNode.isVisited = true;\r\n    visitedNodesInOrder.push(startNode);\r\n    while (queue.length != 0) {\r\n        const node = queue.shift();\r\n        if (node === endNode) return visitedNodesInOrder;\r\n        const side_nodes_x = [0, 0, 1, -1];\r\n        const side_nodes_y = [1, -1, 0, 0];\r\n\r\n        for (let i = 0; i < 4; ++i) {\r\n            const { col, row } = node;\r\n            const new_x = row + side_nodes_x[i];\r\n            const new_y = col + side_nodes_y[i];\r\n            if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\r\n            const neighbor = grid[new_x][new_y];\r\n            if (neighbor.isVisited == true || neighbor.isWall == true) continue;\r\n            neighbor.isVisited = true;\r\n            queue.push(neighbor);\r\n            visitedNodesInOrder.push(neighbor);\r\n            neighbor.previousNode = node;\r\n        }\r\n\r\n        if (diagonal === true) {\r\n            const diagonal_nodes_x = [1, 1, -1, -1];\r\n            const diagonal_nodes_y = [1, -1, 1, -1];\r\n\r\n            for (let i = 0; i < 4; ++i) {\r\n                const { col, row } = node;\r\n                const new_x = row + diagonal_nodes_x[i];\r\n                const new_y = col + diagonal_nodes_y[i];\r\n                if (!(new_x >= 0 && new_y >= 0 && new_x < grid.length && new_y < grid[0].length)) continue;\r\n                const neighbor = grid[new_x][new_y];\r\n                if (neighbor.isVisited == true || neighbor.isWall == true) continue;\r\n                neighbor.isVisited = true;\r\n                queue.push(neighbor);\r\n                visitedNodesInOrder.push(neighbor);\r\n                neighbor.previousNode = node;\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}